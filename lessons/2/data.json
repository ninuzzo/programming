[
  [1, "<p>When you type on your computer keyboards, you are inputting single characters. Each character has a numeric code associated with it, according to a certain table, which may differ depending on the configuration and kind of computer.<p>If you type a number, e.g. 123, that is just a sequence of three characters or string, which in Lisp you quote: \"123\". A piece of software is needed to convert this string into a true number which is stored by the computer in base 2. For simplicity we will only tackle the problem of reading integer numbers."],
  [1, "<p>In positional numerical systems, each digit has a weight depending on its position. That's why they are dubbed positionals. More precisely, a digit's weight is 10 to the power of its position, where the position is counted from right and starting from 0. E.g. in 123, 1 really means 1 times 10^2 (that is one hundred) and its position is thus 2:<pre>210 positions<br>123 digits</pre><p>2 has a value of 2 times 10^1 (two tens) and 3 just 3 times 10^0=1 (3 units). You can spell out any number into a sum of weighted powers of ten, with weights being the number's digits, here in bold face:<p>123 = <b>1</b> 100 + <b>2</b> 10 + <b>3</b> 1 = <b>1</b> 10^2 + <b>2</b> 10^1 + <b>3</b> 10^0"],
  [1, "<p>We will now factor out 10 repeatedly from this formula, so that we have no more powers, only multiplications:<p>123 = (<b>1</b> 10 + <b>2</b>) 10 + <b>3</b><p>Since 0123 is the same as 123, we can start with a redundant zero:<p>123 = [(<b>0</b> 10 + <b>1</b>) 10 + <b>2</b>] 10 + <b>3</b><p>Can you see an algorithm emerging here? If you are presented with a number's digit left to right and want to compute its value, you just multiply the value found so far by ten and add the next digit to find out the new value. Therefore, if so far you have read 12 and you get a 3, you do 12 by 10 = 120 plus 3 = 123, and this is the new value.<p>The above development of a number, where there are no powers of ten, only multiplications by 10, is called Horner's formula, in honour of <a href=\"http://en.wikipedia.org/wiki/William_George_Horner\" target=\"_new\">William George Horner</a>, a british mathematician who lived in the 19th century."],
  [1, "<p>BTW note every time you write a constant number in Racket Lisp - e.g. in (quotient x 10) as we did in the previous lesson - that is just a character string, namely a sequence of two characters, 1 and 0 in this example. Lisp converts this string into a binary number so that the division can be performed. Here an algorithm like the one we are developing is at work! Even if you input a number directyle in binary by prefixing it with #b, this is just a sequence of characters and must be converted into a number by the same algorithm, only we multiply by 2 instead of 10 at each step.<p>Before we begin to code, we need to know how to get the character sequence to convert into a number. If you think about it, that can come from many possible sources. We can just type it with the keyboard (and that's what we'll do for manual testing), but it could also be stored in a file, retrieved by an internet connection or simply preexist in memory as a string (this will be the case for automated testing). It will be a good thing if our program does not depend on the kind of source and will work wherever the number comes from."],
  [1, "<p>This is doable in Racket Lisp, which abstracts all data sources under the concept of \"<a href=\"http://docs.racket-lang.org/guide/i_o.html\" target=\"_new\">port</a>\". This is not a port for ships, but its meaning is akin to the Italian word \"porta\", which means door. A port is the door to generically access a data source for input and/or output. The way you read and write from a port is always the same, no matter what kind of port it is, but of course, you have to use different functions to open the port in the first place, depending on the type of port.<p>Our string-to-number function will just receive an input port (a port you read from) as a parameter and won't know what kind of source that is and neither needs to know that. It will be the caller's duty to create this port and bind it to a real input source - there are builtin functions for that."],
  [1,"<p>Moreover, this input port parameter to our string-to-number function, which I have called \"in\", is optional, because there is a concept of current input port (and also current output port). If in is missing we will call the function current-input-port to get the current default value for the input port. This same function can be used to set an input portas default, if, instead of being called without any parameter, one argument is specified. By making a certain port current, the user can call many functions working on it without the need to specify every time what port they have to use for doing i/o.<p>To read the next character from a port, you use the function read-char, which returns such character."],
  [2, "<p>Do not forget to add the string-to-number function to the list of functions exported by the numbers_io module, else we won't be able to use it in an external program, like our test program test_io.rkt"],
  [3, "<p>The first version of our function just reads one character from the current input port, which by default is the keyboard and returns it. Here is a simple program for testing. When you run the program, a text box appers in the interaction panel, where you can type one line of text, using Enter to end input. DrRacket arranges for this text to be read through the current input port."],
  [4, "<p>After you press Enter, the program goes on and the first character you typed is printed, because that is the value returned by the first version of string-to-number. Note single printable characters are printed as #\\ followed by the character. This is how you represent them as constants in Racket Lisp too."],
  [5, "<p>Now run the program again and this time, instead of inputting something, press the \"eof\" button beside the text field. eof is a special value (distinct from all other values and not a character) that represents the end of a data source. eof stands for \"end of file\" and is printed as #&lt;eof&gt;. What happened is read-char returned eof because there were no characters available."],
  [6, "<p>We now change string-to-number to return the value of the digit character, so not a character, but a number, although less than 10. For doing that we need to convert the character into an integer, which is the job of the builtin char->integer function. This will return the code associated with the character. In doing this, we are supposing no eof is encountered, since eof is not a character, so it would be an error to try to find out the numerical value of eof with char->integer."],
  [7, "<p>I run test_io.rkt again, input 123 in the text field and now you see a number, 49, is returned. This is the code for #\\1, that is the character 1. Code for 0 will be 48, for 2 50, 3 51 and so on."],
  [8, "<p>Since we know digit characters from 0 to 9 have all consecutive codes, if we subtract the code of the zero digit character #\\0 from that of any other digit character (including #\\0), we will found out the distance between their codes, which equates the value of the digit character, when the digit character is interpreted as a digit, that is as a number.<p>This expression should work whatever code the computer is using, as long as digits are all coded with consecutive numbers and fortunately this is true for any sane code out there. By computing the code of 0 with (char->integer #\\0), rather than just writing 48, we make our code more portable, meaning it can work as it is on different kinds of computer - where Racket Lisp is available, of course. This is another advantage of using a high-level language like Lisp versus the computer's native low-level language: the same Lisp program can work with many kinds of computer, if we are careful to code it without relying on anything which could be specific of a certain computer only. On the contrary, if we used machine language, since each computer may have a different machine language, our machine language program written for one computer may not run on another of a different make or even model, unless they all belong to the same \"family\"."],
  [9, "<p>We now test if the first digit value is correctly returned. I input 123 and I got 1, this is the value of the first digit character, so all right. Before we got #\\1, a character, now we finally get a number. Remember we need to convert each digit character into its corresponding digit value, because we then need to multiply the digit by ten and multiplying a character by a number would not make sense. You can only multiply two numbers together."],
  [10, "<p>I think, for readability, it is better to create another function for converting a digit string into its value. This is both for readability and because such a function can be useful for other tasks, so we will make it public, that is you need to provide it."],
  [11, "<p>We can now use this function in string-to-number. You can test the function again and see that it returns only the first digit, as a number, just as before. Nothing changed, save that the function implementation is now simpler and thus a bit more clear.<p>If we want to read all digits and build the resulting number, we could use read-char, but note we'll only know when to stop when we'll have read the next non-digit character after the last digit group, unless the last digit is really the last character in the input port, so that the last read-char we run returns eof. So, unless there is nothing else in the data source after the number we are reading, our string-to-number will consume one more character after this number, that is the function will read and discard it, because it is not a digit. What is worse, this character won't be available to other text-processing functions which the user may want to call next to the call of string-to-number. The user of our function may not expect our function to have this undesiderable side-effect. We could return the non-digit character along with the read number, but this will make our function more difficult to use.<p>The best solution is not to read a character right away using read-char, but have a peek through the peephole before opening the port, so to know what's coming on and only use read-char if we are sure the next character will be a digit."],
  [12, "<p>peek-char is like read-char, but peeks instead of reading. It returns the character a following read-char call would return, but without advancing the reading head on the data source. If there isn't anything more to read, it returns eof, just as read-char.<p>We also need another standard function (char-numeric) to ascertain whether the next character is a digit, before reading it using read-char. By convention, function names ending with a question marks are predicates, meaning they return either true (also #t) or false (#f). These are the two truth values in traditional logic. They are also called Boolean values, in honour of the famous English logician <a href=\"http://en.wikipedia.org/wiki/George_Boole\" target=\"_new\">George Boole</a>.<p>This version of the program will return the first digit as before, but if there is no such digit, it won't read anything from the input source and return false."],
  [13, "<p>Here we are testing it. We input \"Lisp\" instead of a number and press Enter..."],
  [14, "<p>Our function returns false and by running read-char afterwards, we confirm no character has been consumed from the input. After the program terminated, I ran (read-char) not only ones, but many times and all characters typed before have been be returned one by one. Once the whole line has been read, I called read-char again and DrRacket presented me with another text field to either enter another line or decree input ends here by pressing the eof button. You can also do neither of the two by hitting the Stop button, which will abort the read-char call.<p>This is how input is typically read from the keyboard: even if your programs reads characters one by one, keyboard input is by default line-oriented, meaning one line at a time is read and stored in memory. This is to allow one to correct possible mistakes until the Enter key is pressed and the line is committed. This behaviour was typical of old computer terminals and still persists in their today's software equivalent."],
  [15, "<p>We now changed our test program to detect whether a number has been typed or not. You now see why we choose to return false if no digit is typed as the first character. In Racket Lisp anything which is different from false is considered true in a conditional, and so will be any number returned, including 0. This implies that our function can also be used as a predicate, which will be true if a number has been read, false otherwise."],
  [16, "<p>Then I ran the program again, this type inputting a number."],
  [17, "<p>This code snippet will print the number (for now only the first digit) if a number string was input, else an error message. BTW if you write (error \"Not a number!\") a real error message is generated, which includes the file name and line number where the error occurred and the program does not go on after the error. Since we need to use the return value twice, one for Boolean testing and another time for printing, we need to store it somewhere in memory. We cannot call the string-to-number function twice, because that would fire the reading of two potentially different numbers and won't return the same number twice. We give the memory position where the number is stored (automatically chosen by Racket Lisp) a name (rather than a difficult to remember numeric address), which we can use every time we want to read or write to that same location. Here I have chosen \"number\". Variables names in Lisp can contain any character except ()[]{}\",'`;#|\\, because these characters are used for other purposes, e.g. we have already seen that () or [] {} delimit lists and \" strings."],
  [17, "<p>This is the concept of variable in programming, which is a bit different from variable in mathematics. The latter is not a memory cell, but a generic placeholder for any value belonging to a certain set (e.g. the set of natural numbers). In math, you do not change the value of a variable and you do not have to always assign a definite value to it, while in programming you always have to initialize all your variables before use and you can even change their value after definition, because they are the abstraction of something physical like memory cells which may be altered and not just symbols standing for elements of a set.<p>Anyway, programs which change variable values directly may be difficult to read (that is understand for humans), debug and test, because you have to follow all variables changes from the beginning of the program execution. So we will try to avoid changing the initial value of variables as much as possible (some say to \"mutate\" variables, so we will use \"mutations\" sparingly)."],
  [18, "<p>Function parameters are also variables and they are initialized by copying: when you call a function, arguments you specify in the call or parameters default values will be used to initialize the parameters of the function, but these variables are only visible to the function and its nested subfunctions and will be freed after the function call ends, thus not lasting during the whole program execution.<p>We will try to avoid mutating function parameters as well. Calling other functions or the same function recursively is ok, since each function call has its own private parameters. If no mutations are present, the code can be understood, tried out and corrected without any additional variables state information."],
  [19, "<p>Variables defined using define at the outer level (outside any function) are global and visible everywhere, e.g. this means number is still existent and accessible after the if. If you do not want that, there is a special form let which creates one or more variables with a scope of existence and visibility limited to it. With let you can limit a variable scope at just a few instructions, those contained inside let after its variable definitions/initialization (bindings).<p>Local binding with let prevents errors, name clashings and may save some memory. Since variables take up space in memory, limiting their scope as much as possible allows the space they occupy to be freed early.<p>BTW for readability you can use square or curly brackets instead of round ones and this is tipically done when using let. The first argument to let is a list of variable definitions, each of which is in turn a list of two elements, variable name and initial value. So instead of (let ((number (string-to-number))) ...) I wrote (let ([number (string-to-number)]) ...), which is probably a bit easier to read for us."],
  [20, "<p>Let's now see what happens if the input source is empty, that is you press the eof button beside the input text field without typing anything. DrRacket is telling you the char-numeric? function expects a character as its first argument, but eof is given."],
  [21, "<p>What happened is peek-char returned eof, which was passed as an argument to char-numeric?, but eof is a special value, not a character and it is a non-sense to ask whether it is a numeric character. Execution of the program stopped with what we call a runtime error, since it happened midway during program execution."],
  [22, "<p>Here is a more robust version of string-to-number, which returns false on eof as well. The user can then differentiate between an eof condition or a not-a-number error. We do not return eof on eof, because eof is true, as any non-false value, so our function won't behave properly as a predicate any more.<p>eof-object? is a predefined predicate which tells you whether something is eof or not. We only read and print the first digit is we are NOT at the end of the input AND the next character is a digit, else we return false (you can write either false or #f). Instead of define we could also use let. Since there is no more instruction after the if, it makes no difference."],
  [22, "<p>Computer memory is made up of big but finite number of cells, each able to contain 1 byte, that is 8 bits, where each bit is either 0 or 1. Each cell can be located by an address and addresses start with 0 instead of 1. As told before, Lisp lets us to use mnemonic names to locate memory cells and will automatically associate them to their respective addresses and appropriately choose these addresses.<p>So we just need to make up a variable name and store the result of peek-char into it. This variable will be local to the function defining it, meaning it cannot be accessed from the outside, also because it won't exist any more after a call to the function: Lisp will reclaim the space taken by the variable for other variables. We define this variable using define, the same special function we use to define functions, but the first argument this time won't be a list of function name and arguments followed by the function code, but just a symbol or identifier which will be the name of the variable, followed by its initial value. I chose to call the variable next-char, because it contains the next character from the input."],
  [23, "<p>Now hit the eof key on input and the test program does not halt any more, but recognizes eof as \"not a number\"."],
  [22, "<p>Now we want to complete this program by reading all other subsequent digits and using Horner's formula to calculate the resulting number. So again we need to loop, which we can do by using a function which calls itself until an exit condition is reached (there are no more digits). We cannot do this easily with one function only, because if the following character is not a digit, we need to behave differently depending on whether this is the first peek (we have to return false) or not (we just have to return the number computed so far, which is the final result). Moreover every time the function calls itself, we will need to pass the partial number computed so far, but we do not want string-to-number to have such additional parameter, because that's an implementation detail we do not want to disclose to the function user."],
  [24, "<p>As we did for the output algorithm (remember successive-divions? if not brush up lesson 1), the solution to these problems is to define a local function, which I have called add-digit, because it does the job of adding another digit to the number (one step of the Horner's development). This function \"accumulates\" the result in its parameter partial-number, which is initially 0 (e.g. 12=(0 10 + 1) 10 + 2, you see the first partial result we multiply by 10 is 0). Its logic is quite simple: if a digit character follows, then read it, convert it into a one digit number, add it to the partial return and call yourself again with this new partial result, else (no digit character follow), result the partial number computed so far, because that's the overall result.<p>In our first implementation, we just move the previous code belonging to string-to-number into a local function add-digit..."],
  [25, "<p>... we then return the partial-number if no digit follows. Instead of returning false. Let's not worry of the case \"first character is not a digit or source is empty\" for now."],
  [26, "<p>... then instead of returning the digit, we add the digit to the number and call the function recursively to add the next digit (if any)."],
  [27, "<p>Finally, to prime the pump we make a first call to add-digit in string-to-number, starting with 0 as the partial number. This makes sense because you can have a 0 in front of any number without changing its value, e.g. 012 instead of simply 12."],
  [28, "<p>Let's test this. On eof, it returns 0 instead of false, but I said to not worry about that for now. Same if the first character is non-numeric. If it can't read a number, it returns zero, making no difference between zero and no number."],
  [29, "<p>But most importantly, it returns full numbers now."],
  [27, "<p>We now just have to cater for the case when the first character is not a digit or the input stream is empty and return false instead of 0. This is a difficulty we saved for last, because we did not want to get overwhelmed by a special case. I often use such a kind of optmistic programming: first cater for the normal case, then modify the code to handle possible errors. It often helps to get the most straightforward code."],
  [30, "<p>One approach is to move the first iteration into string-to-number. So string-to-number will check whether the first character is a digit and if not will return false, if yes will call add-digit with the first digit as the partial number. To avoid code repetitions, I have created a local predicate function called digit-follows? that will return true if a digit is following, false otherwise, without reading it and nother named next-digit, which will read the next characters and convert it to a digit. You can test false is returned on eof or on unexpected non-digit character now."],
  [31, "<p>Another way would be to add a boolean parameter to add-digit, which tells whether this is the first call of it or not. Then we query this parameter in order to decide whether to result #f or partial-number. This time the special case is handed inside add-digit. Although the complicated Boolean expression is evaluated only once, I still defined a digit-follows? predicate just because it makes the program easier to read. Alternatively you can comment the expression by writing ; digit follows? after it. ; introduces a comment and Racket Lisp will ignore everything from ; till the end of the line. Similarly, I kept the definition of next-digit. It's ok to have a function that is called only once if it makes the algorithm a bit more modular and thus easier to read.<p>BTW there is a <a href=\"http://docs.racket-lang.org/reference/generic-numbers.html?q=string-%3Enumber#%28def._%28%28quote._~23~25kernel%29._string-~3enumber%29%29\" target=\"_new\">string->number</a> built-in function which behaves just as ours."],
  [32, "<p>To round off our simple i/o library, we also provide a function to skip all <a href=\"http://en.wikipedia.org/wiki/Unicode_character_property#Whitespace\" target=\"_new\">whitespace</a> from a certain input port. This includes blanks, newlines, tabs, etc. This function must also peek at the next character, because we do not want to read it in case it is not a whitespace.<p>This is a white-space eating function, as you can see from the recursive call to itself as its last instruction. BTW this is called <a href=\"http://docs.racket-lang.org/guide/Lists__Iteration__and_Recursion.html#(part._tail-recursion)\" target=\"_new\">tail-recursion</a>. All our recursive calls have been of this kind so far. It matters because this kind of call can always be optimized at the machine language level both for time and space (transformed into a simple loop with only one function call at the beginning). This optimization is always made by Racket Lisp. We won't go into the details of this, because it requires some knowledge of machine language and how function calls are implemented which is out of the scope of this book. But it is good to know that our high-level programs using tail-recursion are as efficient as lower-level ones, plus easier to read, write and modify."],
  [33, "<p>We will see how to loop without recursion in other lessons. In some cases we can and will want to avoid recursion that is not tail-recursion (the recursive call is not the last instruction of the function) and is slower. In other cases, depending on the algorithm, even non-tail recursion is optimal and replacing it with a loop won't gain anything.<p>Tail recursion is an idiomatic way to loop in Racket Lisp and as we noted above is not inefficient. Anyway, there is another one, the so-called <a href=\"http://docs.racket-lang.org/guide/let.html#(part._.Named_let)\" target=\"_new\">named-let</a> form. But it is nothing different from tail-recursion. It is just another syntax, which limits the recursive function definition to a local scope. If after let you put an identifier (before the variable bindings list), the code inside let can be repeated by calling a (local) function having this same name. Variable bindings define this function arguments and their first-call value. The pump is primed for you, meaning there is an implicit first call to the function which causes the first execution of the code inside let. Here is a re-write of string-to-number using a named let. You may want to compare it with the first version: they are completely equivalent, save that add-digit is not available after the let (but there is no more code in string-to-number after let, so this makes no difference in this case)."],
  [34, "<p>We now test skip-whitespaces. You just insert a call to it before string-to-number and all blanks before a number will be skipped."],
  [32, "<p>skip-whitespaces returns nothing, which is a special value <a href=\"http://docs.racket-lang.org/guide/void_undefined.html\" target=\"_new\">#&lt;void&gt;</a>. This is called \"the invisible value\" because it is never printed in the interaction panel to not clutter it. A function returns what its last instruction returns and in this case, the recursive function ends when the when condition is false and when has nothing to return, so it returns nothing, that is #&lt;void&gt;."],
  [35, "<p>This is another version of skip-whitespaces which returns the next non-whitespace character instead of nothing. Should the caller code need this value, it could get it using peek-char. So why returning it from skip-whitespaces? Just to save another peek-char call.<p>Here we are using cond instead of if. cond is a more general selection function, equivalent to a chain of ifs (if something then this else if something-else then this-other else ...). Anyway we just have a single if here, but we are using cond because it allows for more than one expression to execute in both the if and else branch, just like when and unless, while if only allows one."],
  [36, "<p>So, if you want to execute more than one statement in the true condition of an if, or in the else branch, you can use cond instead of an if. There is also another way. You cannot just wrap both commands in parens - e.g. ((read-char in) (skip-whitespace)), because that would mean to call a procedure whose name is returned by the first statement and the second one is its parameter. Apart from cond, the other solution is to wrap the statements around the begin form. This delimits a block or sequence of instructions. It evaluates them all left to right and returns what the last one returns. The body of a cond clause has an implicit begin, just like the body of a function definition or a let, but if does not have it because there is no else keyword to separate the then and else branch, so to tell what instructions belong to each of the two branches, you need to use (begin ...) to wrap more than one statement."],
  [37, "<p>Here's the fruit of this lesson's labours. I have just added a base parameter which is the radix of the positional system, by default ten. This allows to read numbers in any base less than or equal to ten, e.g. you can read a binary number, just like Racket Listp does if you write #b1010."],
  [38, "<p>We eventually code some tests for string-to-number too. open-input-string accepts a string and returns a port to read that string. You see how we now need to abstract input, since input for tests cannot come from the keyboards. Tests need to run unattended."]
]
