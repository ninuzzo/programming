[
  [1, "<p>Fundamental algorithms... not games! But do not worry, you will find interest and reward in the process of learning itself. Programming is understanding and each problem is interesting in itself. It's a gym for the brain and we like to make our brains tick.<p>Enough for an introduction. Let's start right away. Probably, amongst the most fundamental algorithms are those for inputting and outputting decimal numbers.<p>Because it is easier to build electronic stuff handling only two states - call them true and false or 1 and 0 respectively - all practical computers internally represent numbers in the binary system."],
  [1, "<p>This is like the decimal numbering system, except you only have two digits: 0 and 1. So 0 is 0, 1 is 1, but 2 is 10 (read \"one zero\"). Think about what you do when you count after 9. You can see 9 as 09 and since you are short of digits, you turn 9 into 0 and 0 into the next digit, that is 1 and you get 10, which we call ten for brevity. You do the same in base 2: 01 becomes 10, because you do not have another digit after 1.<p>3 is 11, 4 is 100, 5 is 101 up to 10 which is 1010. That is easy to remember: ten ten is ten in binary. You see in binary \"round numbers\" are all powers of two while in decimal they are all powers of ten (that is in both cases of the base): 1 is 2^0, 10 (2) is 2^1, 100 (4) is 2^2, 1000 (8) is 2^3 and so on."],
  [1, "<p>Now computers all do their calculations in binary, but binary numbers can get very long and we want the output in decimal. We then have to instruct the computer on how to do it.<p>Of course this problem has already be solved by computer manufacturers or operating systems developers and you can just use their solution. But we are going to do it again, this time in a high-level language, distant from how the machine really operates, in order to learn about algorithms. This language is Racket Lisp and you can get its interpreter, which translates it to the computer low-level language at <a target=\"_new\" href=\"http://racket-lang.org/\">http://racket-lang.org/</a>"],
  [1, "<p>Let's start by considering the opposite problem, since it is easier for us to calculate in decimal than it is in binary. If you were to translate a decimal number into binary, how would you do it? Since each binary digits has a weight of a power of two, you would just see how many 1 (2^0), 2 (2^1), 4 (2^2), 8 (2^3), etc. there are in the number. But how to do that?<p>First notice if you repeatedly divide a decimal number by ten - until you get 0 - and consider the remainders of such divisions, you get its digits from right to left, that is in reverse order. Eg. 123/10=12 with a remainder of 3 (last digit!), then 12/10=1 with a remainder of 2 (last but one digit!), and at last 1/10=0 with a remainder of 1 (first digit!)."],
  [1, "<p>This is no surprise because by dividing 123 by 10, you see how many tens there are in it and you are left with the number of units, which is the remainder. Then if you divide 12 by 10, you are just finding out how many hundreds there are in the original number 123 and you are left with just the number of tens and no further units, while if you divided 123 by 100 you would have 23 as the remainder, which has both tens (2) and units (3).<p>So you see why we need not to divide the same original number by 10, 100, 1000, etc. but the result of the previous division by the next power of ten, if we want to get a number's digit in reverse order using a mathematical process - that is an algorithm."],
  [1, "<p>Now back to the original problem, how to see how many powers of two are there in a decimal number? We have just seen how to find out how many powers of ten there are - those are just the number's digits - and you find them by dividing repeatedly by ten and taking the remainders. There is no reason why this should not work for powers of two or any other base as well. There is nothing special with the base 10. We happen to have 10 fingers on our hands, but arithmetic would not be different if we had only 2 or 3 or more, e.g. 16."],
  [1, "<p>So if I divide a number by 2 (the destination base, analog to 10) and take the remainder, I found out the number of binary units that are into it. The division result I can divide by 2 again to find out how many \"binary tens\" - better called \"binary couples\" - there are as the remainder. The important thing to remember is that by dividing repeatedly by a certain base (e.g. 2), you are dividing by the successive powers of that base (e.g. 2, 4, 8, 16,...) and at every step, you get the number of the PREVIOUS power contained in the number as the remainder, and only that, because as the dividend you always take the result of the previous division.<p>For how tricky it may be, it should make sense why it works now. So let's take 10, which we already know will be 1010 in binary and see if the result matches: 10/2=5, remainder 0 - last digit in 1010 is indeed a 0. Then 5/2=2, remainder 1 - that's the last 1 in 1010 or second digit from the right. Then 2/2=1, remainder 0 - 0 is indeed the third digit from the right. Lastly 1/2=0, remainder 1 - the fourth digit from the right. So we got the digits of the binary number corresponding to 10 in reverse order: 0,1,0,1. Reverse this list to get 1,0,1,0, that is 1010."],
  [1, "<p>If we continued to divide from now on we would get only 0 as result and 0 as remainder, becase 0/2=0 with a 0 remainder. You can indeed put an infinite sequence of zeroes before any number (e.g. ...000001010) without changing its value because these zeroes do not add to the number value. So we better stop when we get a zero result."],
  [1, "<p>Now if all this works to convert from base 10 to base 2 by doing calculations in base 10, there again is no reason why it should not work to convert a number from base 2 to base 10, by doing calculations in base 2, as all computers do. You can calculate in base 2 using the same processes (algorithms) you use in base ten, which we will formalize better in later lessons. E.g. for addition:<pre> 1\n1010 +\n  11 =\n------\n1101</pre><p>You see 1+1=10, you write 0 and carry 1. This sum in decimal is 10 + 3 and the result is 1101 which you can see it is indeed 13 (1010=10, 1011=11, 1100=12, 1101=13)."],
  [1, "<p>So we will instruct the computer to repeatedly divide by 10, taking the rest of divisions - which it performs in binary using some clever circuitry - and print them in reverse order. This way we will have converted any number from its internal binary representation into decimal, which is what the computer does every time it spits out a number. BTW note that given current tecnology it would be too expensive to make computers perform calculations directly in decimal as we wanted, so this little piece of number-converting software is really needed."],
  [1, "<p>Install and launch <a href=\"http://racket-lang.org/download/\" target=\"_new\">DrRacket</a>.<p>This is the empty program which does nothing. It just states it is written in the Racket Lisp language, one of many high-level languages you can talk a computer to, but as you will soon see both a powerful and an easy to use one."],
  [2, "<p>Let's begin to save the program. Press Ctrl-s or go to the File menu and select Save Definitions. We choose a file named successive_divisions because that's the algorithm idea and give it a .rkt extension, which means it is the source of a program written in the Racket Lisp language."],
  [3, "<p>We will write a function that does the conversion. A function is a bunch of code you can reuse by invoking it. It has a name and you pass in some input data - which may be nothing in some cases - and get a result - which may be nothing or you can also have some side-effects like printing something on the screen, changing the internal state of the program, etc."],
  [4, "<p>If you know (or better remember) some high-school math, a computer function is like f(x)=x+1 - e.g. f(2)=3, you put in 2 and get the next number: 3 -  except it can also do more than a simple formula, even launching a rocket. Let's name the function number-to-string. You define a function by invoking the special function (or form) define and instead of f(x) we use the syntax (f x), which is just a precise way to write a list whose first element is the function name and parens act as delimiters, marking clearly the beginning and end of the list.<p>Here f is defined and the argument x is really another nested list: the function name and its arguments, for now only one, the number to convert. We will call it x, but any name will do. Try to choose informative names, but this is just any natural number, so I can't figure out a better name for it. Of course any-natural-number would probably be a better name, but it's too long to write more than one time and I think it's already clear from the context what x is."],
  [5, "<p>After the first argument - the (number-to-string x) nested list - goes the code to execute every time the function is called. In our first version of the function, we will just print the rightmost decimal number or number of units contained into x. For this we use the already available (or built-in) function remainder, which you can try out in the interaction panels as shown.<p>So the code of a function is usually just one or more calls to other functions and until we write some code in the function definition, DrRacket - roughly the software \"daemon\" which lets your computer speak Racket Lisp - is complaining there isn't any."],
  [6, "<p>Of course, a function with no code would not make much sense.<p>As you may have guessed, there are two main panels: the lower one is for quickly trying out functions and pieces of code (as we did with remainder), while the upper pane is for writing a program file that can be stored permanently. Commands typed into the upper pane are not executed immediately. Indeed DrRacket is remembering you that you have to click on the left green arrow button named \"Run\" if you want your entire program to be executed."],
  [7, "<p>So run the program. It may seem nothing happened. Although nothing has been printed, something changed offstage. Your computer now knows about a new function named number-to-string, which you can now try out in the lower interaction panel as I did. Thus defined our function is just a specialization of remainder. It gives out the remainder of the division by ten, which is a number, not a string (sequence of characters)."],
  [8, "<p>We next wrap another function call in order to print rather than to return this value. To update the in-memory definition of the function, you have to click on the Run button again before trying it out in the lower panel, else you would still be trying the previous version of the function. DrRacket won't warn you this time, because it cannot know whether you want to try out again your new or old function definition. Note the interaction panel is cleared every time you Run the program again.<p>Although not mandatory to just put your new program version to the test, you sometimes may want to hit Ctrl-s to save the program file on permanent memory (usually a disk), just in case of a blackout - especially important on a desktop computer lacking a battery. When the current program is saved, there is no * at the end of window title, as there was on the previous slide.<p>Also note the interaction panel shows either values returned or displayed by a function. This is for your convenience. When a function is called during a normal program execution, if it just returns a value, nothing will be printed unless the program explicitely makes a call to another printing function. But the interaction panel behaves specially to make it easy for you to try out your programs."],
  [9, "<p>We now want to compute and display all other digits of number x. But we do not know a priori how many digits there are. Ok, we could tell the computer to count them, but we want to keep our code as neat and clean as possible. Since we know when to stop, that is when the quotient is zero, that's all we need to print all digits.<p>So how do we loop to print the next digit? We just let the function call itself with the result of the x / 10 division. Integer division is performed by a built-in quotient function. We nest a call to that function in the recursive call of number-to-string - that is how we call a call of a function to itself, because we can say we \"recur\" to the same function in order to complete the computation of the function. If you try out this program - do not forget to Run it before, I won't say it any more. You will find out that it will never end and you will have to press the Stop button."],
  [10, "<p>After having stopped this wild, crazy program, I scrolled up to see what happened. I noticed all number digits have been printed, though in reverse order, followed by a never-ending string of zeroes. The first part of the output is correct, but then, of course, if the function continues to call itself every time a new instance of the function executes, it will never come to an end."],
  [11, "<p>We said before we have to halt when the quotient is zero. We need to test for that. Of course, there is a built-in = function as in mathematics, except 5 = 4 is written as (= 5 4). This language consistently puts operators (like =, remainder, quotient, etc.) before operands (like 5 and 4) and always uses round brackets to tell where the operands end (necessary in case of more than two operands) and what operations to perform first.<p>We also need a way to alter the course of execution based on a condition or said differently a way to select some instructions to execute only if a certain condition is true. For that there is a special function or form called when, whose meaning is: when the condition holds (it is true) execute the following piece of program (typically function calls) else (condition is false) just go on with the next instruction, if any - none in this case. Since we have to recur when x is not zero, we actually need the \"different from\" operator rather than the \"equal\" one, that is we need to test for inequality rather than equality. There is no such operator, but a logical operator called not which reverses the logical result of any other operator, e.g. while (= 5 4) is clearly false, (not (= 5 4)) will be true.<p>Try now and you will see the program terminates, but since we first print the remainder of x divided by 10 then check whether x is zero, a 0 is always printed before returning from the function. E.g. for 5 the result is 50, to be interpreted as 05."],
  [12, "<p>So there's a pitfall when coding programs: they may never end and we must try to avoid that, else they won't be correct. If your computer ever hanged you now know what's going on... it must be stuck in an infinite recursion or loop! Well, we will actually need to wait an infinite amount of time to be sure of that from the outside. It could just be in a long but finite wait, waiting for some event to happen or even a meaningful but long computation.<p>We now try to avoid printing that 0 as a last digit: we first test whether x is different from zero and only if it is, we will print the remainder and recurse. BTW there is also an unless function which is equivalent to when combined with a not. We use that now, for added brevity. Note now if the unless condition does NOT hold, then the two function calls (display and number-to-string) are executed. Now there is no leading zero anymore, but unfortunately we have another problem: if x is initially 0, nothing is printed. How to solve that?"],
  [13, "<p>We just have to treat the case \"number is initially zero\" specially. We initially have to check whether the number is 0. If yes, we print 0 and we're done. Else, we display the last digit (units) and recurse to print the last digit of the number divided by 10 and so on, until we stop because the new quotient is zero.<p>We cannot do this in one function only, because the code we need to repeat does not have to include the initial test for zero which prints a zero. So what was before the number-to-string function has become a local function of the new number-to-string and has been renamed to successive-division. Local means only number-to-string can call this function and indeed only number-to-string needs to call it.<p>What in English is: if condition then do this else do that, in Racket is a bit less verbose, with no else wording: (if condition this that). Note either this or that is executed, never both, but surely either. when and unless do not have an else clause: they can only be used to guard the evaluation of some code, that is to allow or prevent it to be executed under a certain condition."],
  [14, "<p>Now we have a working program, but we are still getting digits in reverse order. How do we fix that? Well, the way the algorithm works is to generate digits in reverse order. We cannot change that. If we wrote right-to-left, we wouldn't have this problem, but we write left-to-right. It looks like the writing direction convention is against math, but it's too late to change it now.<p>The solution is of course not to print a digit as it is generated, but to store it somewhere and print everything all together at the end of the feat. This requires a reformulation of our function. If you think of a single digit as a dish (or better draw each digit on a dish), it is like stacking dishes and afterwards fetching them top to bottom as they come. They will always come out in exactly the reverse order. Now every time the algorithm generates a digit, we convert it to a string, which is something stackable as a dish. To be precise a sequence of 0, 1 or more characters, only one in this case and we can concatenate these sequences as we can stack dishes. This is the job of the number-to-string built-in and then we build a new string by appending this new digit to the rest of the digits string computed so far. In other words, we are putting a new dish on top of the dishes stack built so far, so for example when printing 123 the \"1\" string will be appended to \"23\", resulting in \"123\", a string of three characters representing our number in left-to-right writing direction."],
  [14, "<p>Note \"the current stack of dishes\" is passed to the successive-division function as an additional argument, beside x, which we have called digits-string. The function just pushes a new dish on top of the stack and calls itself passing the new stack value, with one more dish. The stack is initially empty, that equates to an empty string \"\" (a sequence of 0 characters). When the halting condition is reached, successive-division will return the current stack, which is the string representation of the number. number-to-string will print this value with a single display call.<p>The built-in function <a href=\"http://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._number-~3estring%29%29\" target=\"_new\">number->string</a> is quite similar to our number-to-string, actually more powerful. It can convert any number into a string, also non-integer numbers like 3.14. In our implementation we are only using it to convert a single digit."],
  [15, "<p>Since we do not know what the number-to-string function user (some other code) wants to do with the number - it may not be wise to print it right away - we better avoid the side-effect of printing it inside number-to-string and just return the number as a sequence of characters (a string). The caller must print it if she wishes. The job of our function should be only to convert numbers to strings, which is more specific than converting and printing.<p>Incidentally, characters are also coded as numbers into computers -  where everything is just 1 and 0 - but display circuitry will interpret them specially and print them as we expect. The reason strings are quoted is the computer just takes them literally. It does not understand what they mean in natural language, provided they mean something. Quotes also serve to differentiate synctatically between strings and other symbols like function names or numbers."],
  [16, "<p>Alternatively we can make the second argument to the successive-division function an optional one. If it is missing, it will be initialized as defined, an empty string. So in the first call to successive-division, this argument can be left out. You may want to press backspace and spacebar repeatedly to see what changed.<p>I like this solution a bit more, because the job of building the number string is all inside successive-division and number-to-string does not have to know anything about that, not even how the string has to be initialized. This better matches the abstraction of functions like black boxes, which you can use without too much understanding of their internal behaviour, but only knowing what to give as input and what the output looks like."],
  [17, "<p>Now that we know how to define default values for function arguments, we can make our number-to-string function more generic, by adding a second argument, which is the base or radix of the output, 10 by default. We will then replace the two occurrences of 10 with this variable name. number-to-string can now output numbers in any base less than 10, e.g. in binary or octal, an alien numbering system where you only have digits from 0 to 7 (8 in total). So that in octal, for example, 8 is 10, 9 is 11, 10 is 12. number->string also has this optional additional argument."],
  [18, "<p>Let's pretend there is no default number->string function or other facility built into the language to output numbers, so we really need to use number-to-string in our programs. We could just copy and paste the definition of number-to-string in each program we write that needs it, but that will result in a massive code duplication. If we ever need to amend the function, e.g. correct a programming error, we will have to do it in every program that uses it.<p>Of course, we need a way to centralize this code. We just keep the code in one separate file. Then we require this file in every program that needs it. The only catch is the former file, which is named a \"module\", has to explicitely tell which functions allows to be called from the requiring program, because by default none is. If you wonder what made the file a module, the answer is the #lang directive, which automatically creates a module named from the file name. In our case there is only one function we want to provide, but in general there could be some functions which we want to keep private to the module: they serve some purposes and are used by other module functions, but it does not make sense for a module user to call them directly. We won't include such private functions in the provide clause."],
  [18, "<p>Note also here I have renamed our program file as numbers_io.rkt (io meaning input-output) since it seems a more appropriate and bombastic name for a reusable module and also because we will add another function to this module in the next lesson, so we cannot name the file after the algorithmic idea of this first function only.<p>As noted before, we need to add a provide call which states we want the number-to-string function to be provided for external usage by this module and only that (for now)."],
  [19, "<p>After having made sure the module file numbers_io.rkt has been saved, I went to File/New Tab or hit Ctrl-T and wrote a simple program using the numbers_io module in a separate file, which I saved as test_io.rkt and then ran that program.<p>Note when you require a module, you have to specify its path relative to the requiring file, but since I kept both files in the same directory, we just need the module file name. If this module were in a subdir named mymodules relative to test_io.rkt, I would have written \"mymodules/numbers_io.rkt\"."],
  [20, "<p>Every time we refined our program, we needed to test it in order to make sure everything is correct. We did that either in the lower interaction panel or by writing a proper test program. For more complex programs, manual testing like this can be tedious. It may take a long just to prepare the input and comparing the output with what is expected. Testing can be automated, just as robots automatically test cars in automotive manufacturing plants. Once instructed by us, it will be the computer itself to provide the input and check the output and it will warn us only if a test fails, usually meaning there is a programming error. BTW programming errors, although today mostly due to humans, are curiously called bugs, because in first valve computers, a bug could really cause a malfunctioning. It looks like programmers do not want to admit THEY make mistakes.<p>There is a standard module named rackunit, which provides functions to ease automatic program testing. One of them is check-equal? which checks whether the first argument is equal to the second and warns if not, else it is silent. It can optionally take a third string argument describing what the test does, which I almost always use. I simply ran test_io.rkt and there was no output in the interaction panel, meaning all tests succeded."],
  [21, "<p>Here I made a test fail deliberately, by pretending 123 should be printed as \"13\", just to show you how the output of check-equal? would be in case of a failing test. Then I hit Ctrl-Z to automatically undo this little change to the source code."],
  [22, "<p>At last, I have moved test code into the module itself. What we want is test code to be available together with the module, if someone ever wants to run the tests, but we do not want to make the module more demanding on memory resources most of the times, when tests are not run. For this reason, we cannot simply put the test code in a function in the numbers_io module.<p>The best solution is to put the test code in a submodule of the module to test. I have called this submodule test and it is a useful convention to use this same name for all test modules. All test code must be within a (module+ test ...) form, in place of the dot-dot-dot. To run tests, just run the module file itself.<p>If you wonder what the meaning of that + after module is... it just means the submodule will be able to access all functions and other definitions in the enclosing module, even if they are not provided to the outside and without any need to require that module. This is something that may be needed for testing. E.g. you may want to test an internal, non-provided function and do it separately from the provided function that uses it, so that you need to call it directly. Tests often need to look under the hood and so we disable any form of access control, which may get in the way when testing."],
  [23, "<p>Note if we import the module in a program, tests included in a submodule are not run, so there is no overhead due to unwanted test code being executed or even loaded. You can confirm that by making a test fail on purpose as we did before and then running this program again: no tests will be executed, so no error will be reported.<p>Therefore from now on, we will always include some automatic test code with all our algorithms. Lately there's been a lot of hype about test-driven development. I'd like to remember tests alone cannot ensure program correctness, let alone guiding programming. Incremental development is the only way to tackle difficulties. Testing is just one aspect of programming and something you need to do, but it is not central to development as some people think. You also need to be skilled and careful when coding algorithms. Tests cannot make up for sloppy programming or bad programmers. A good tester is not necessarily a good maker.<p>If we can demonstrate an algorithm's correctness mathetically, we will do it, because that is the only way to ensure 100% correctness. But, unfortunately, such demonstrations often end up being much more complex than the algorithm itself and we have to be contented with a less certain belief of correctness, as given partly by tests, but mostly by the way we devised the algorithm and the choices we made."]
]
