[
  ["1.jpg", "<p>This is the first lesson on fundamental algorithms of computer graphics. We are going to make a movie of a horse running and in the next lesson, we will simulate the free falling of an object.<p>The British photographer <a href=\"\">Eadweard Muybridge</a> was a pioneer of cinema in the 1900s. He made a famous sequence of photos, known as \"The Horse in Motion\". I have cropped each of the twelve frames from <a href=\"http://upload.wikimedia.org/wikipedia/commons/7/73/The_Horse_in_Motion.jpg\" target=\"_new\">this picture</a> and saved them into separate files named horse##.jpg, where ## is the frame number. If we show these images in sequence, each every 1/25th of a second, we will have a movie of a galloping horse."],
  ["1.jpg", "<p>We begin by loading images. Images are saved using compression algorithms, but in the end they are just a sequence of 0 and 1 (bits) and thus just a kind of value, so they can be put into variables. We have twelve frames, should we make twelve separate variables, e.g. named FRAME1, FRAME2, etc.?<p>Consider during the animation we will need to access values of frame variables (that is frames image data) using cardinal numbers. This is simpler to do if we store all variables consecutively in memory and keep track of the address where this arrangement (or \"array\") of variables begins in memory. If all variables are of the same size, we can then compute the address of each variable by adding to the array address the variable size multiplied by the variable number in the array (aka index)."],
  ["1.jpg", "<p>Some mathematicians will say that the address of a variable in an array is a linear function of the index variable:<p>variable-address(index) = variable-size index + array-address<p>where array-address is a constant. Since computer memory can be accessed randomly and we can compute the address of a variable in an array with such a simple formula, we can access each element of an array in constant time. We do not have to browse all elements before the one we need: we compute the address almost instantly, no matter how big the array is and fetch or change that element directly.<p>Anyway, this requires all variables in the array to be of the same size, while image data, because of the compression algorithm, will generally have a different size. Our frames, despite being all of the same dimensions (360 pixels in horizontal direction and 230 in vertical), have file sizes varying from about 17 to 19 kilobytes (1 kilobyte = 1024 bytes and 1 byte = 8 bit, a sequence of eight binary digits, each of which is either 0 or 1)."],
  ["1.jpg", "<p>The solution is to store the actual image data somewhere else in memory and arrange in an array not the image data, but their addresses (also called pointers or references). Since addresses have all the same size on the same machine, that will be the value of \"variable-size\" in the above formula.<p>This is what Racket Lisp does whenever you use arrays. In other words, Racket Lisp arrays are always arrays of references rather than values, so that the same array can contain values of different types and sizes (e.g. strings, numbers, even other arrays, etc). Actually Racket Lisp arrays are of a fixed length (number of elements or slots) and are thus better called <a href=\"http://docs.racket-lang.org/reference/vectors.html\" target=\"_new\">vectors</a>, as in mathematics.<p>Vectors whose elements are constant (this is our case) are defined by wrapping the list of elements around #( and )."],
  [2, "<p>With the cursor inside #( ) select Insert Image... from the Insert menu, select the first frame file and confirm by clicking the Open button."],
  [3, "<p>The image will be shown amid code! This is because images in Racket Lisp are just like all other values, e.g. numbers or strings. They evaluate to themselves and are displayed (rendered from image data) when printed."],
  [4, "<p>Save this program with the name horse.rkt. If you open it with another editor, you will see it was saved in GRacket format. GRacket is the graphical variant of the Racket Lisp interpreter. Thanks to this encoding, images will be embedded into our program. Return to DrRacket and insert all other frames."],
  [5, "<p>This is the result. I have reduced the images size so you can see them all in this small window screenshot. A blank between each image serves to separate them visually, but it's optional for a list of images.<p>Note I assigned this literal image vector to a vector variable called FRAME, using define as usual. By convention, all uppercase variable names should not be modified, that is you should not change their values. They are to be treated as constants.<p>Run the program and experiment with the vector-ref function in the interaction panel. It returns the element in a certain slot of a vector (index). Slot numbers start from 0 and the reason is that formula:<p>variable-address(index) = variable-size index + array-address<p>Since the first element is at address array-address, you get its address with index equal to 0. With index equal to 1 you get the address of the second element, not the first one. So last index is 11, one minus the array length. Element at index 12 does not exist and trying to get it triggers an error. It took a lot of time for men to realize 0 is a number and we should start counting from 0. Our computers do that too when counting the elements of an array."],
  [6, "<p>This is the first version of our animation program. The function create-horse-scene will be called every 1/28th of a second (this is near to 1/25th, just a bit faster) by animate, a function of the 2htpd/universe library designed to create animations.<p>It is the first time you see a function as an argument to another function. This is doable in Lisp and useful every time we want to plug an external behaviour into an algorithm. create-horse-scene actually receives the number of ticks passed since its call, but this in our case happens to be equal to the frame number. The first time create-horse-scene is called, its argument is 0, which is exactly the index of the first frame number, since arrays are indexed from 0.<p>create-horse-scene fetches the current frame from the FRAMEs array using vector-ref and then calls a function of 2htpd/image to display it. The best way to explain this complex call is to just read in natural language: it is asking to place the CURRENT-FRAME image onto an empty scene, which has just the dimensions of the image. It's just an empty canvas with a thin black border around it. The top-left corner of the CURRENT-FRAME image is placed at coordinates 0,0 of the empty scene. These are at the top-left corner of the scene too, so that the CURRENT-FRAME will completely cover the scene."],
  [7, "<p>Try something like (empty-scene 360 230) in the interaction box to see like an empty scene looks like. It's just an empty canvas with a thin black border around it. Unlike math, when addressing pixels on a display, the ordinate is directed downwards, not upwards and the 0,0 point is not the at the display center, but the very first pixel in the top-left corner.<p>Why is it like that? The state of each pixel must be kept in memory. To both ease programming and making displays cheaper, hardware designers long ago decided to use a portion of central memory as video memory. They mapped pixels state into memory starting at a certain fixed address and the mapping was naturally made top-to-bottom and left-to-right. The address of a pixel is then found by this simple 2-variables function:<p>pixel-address(x, y) = pixel-size x + horizontal-resolution pixel-size y + video-memory-address<p>For our empty-scene, horizontal-resolution will be 360, pixel-size and video-memory-address are constants too. You see pixel-address(0, 0) is equal to video-memory-address which is the address of the topmost and leftmost pixel."],
  [8, "<p>If you run this, you will see the animation stops after the last frame (the one where the horse looks stationary with all its four feet resting on the ground). What happened is the same thing when you run vector-ref with an out-of-range index. The frame-number parameter became 12 and there is no 13th element in the array. What to do now?"],
  [9, "<p>We do not want to stop our animation at the last frame, but create the impression of a continuing movement. For that we have to start over, that is showing the first frame for frame-number equal to 13, the 2nd for 14, etc. For added clarity, we better rename the function parameter tick-number since it is a frame number only in the first few calls.<p>Therefore we will take the remainder of the tick number divided by the number of frames (number of elements in the FRAME array, which we find out by using vector-length, so that nothing else has to be changed if you add more frames or remove some). This is mathematically guaranteed to always be less or equal to the last frame index (<12 or <=11) - in more general words the remainder is always less than the divisor - so the \"index out of range\" error can never happen now."],
  [10, "<p>BTW if you have a good sight, you will realize you better not use the last frame (where the horse comes to a standstill). Just click after this last frame in the definitions panel and use the backspace key to delete its image, just as you would delete any character to the left of the cursor. Nothing else has to be changed in the program, since we calculated the array size by using vector-length, so there is no 12 to change into 11. This done, run the program again and you will get a smooth animation of a horse continuing trotting forever like the one shown here."],
  [11, "<p>If you run the animation now, you will see that it will never stop, unless you press the Stop button or close the animation window that pops up when you run the program.<p>Clicking Stop will interrupt the program abruptly and generate a user-break error somewhere in the midst of some internal library code and won't close the animation window."],
  [12, "<p>The recommended way to halt the program is thus to close the animation window. The program will then terminate normally, that is return from the animation function and continue to execute possible other instructions after animation. Note animation prints the number of clock ticks that have passed on returning."],
  [13, "<p>And to conclude, I want to mention Muybridge made this photo sequence  to demonstrate there is a time when all four feet of a horse are off the ground at the same time while trotting. This you can clearly see from frame number 1 or 2, of course both counted from 0!"]
]
